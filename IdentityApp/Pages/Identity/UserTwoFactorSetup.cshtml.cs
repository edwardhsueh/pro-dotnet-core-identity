using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using System.ComponentModel.DataAnnotations;
using System.Threading.Tasks;
using System.Linq;
using System.Text.RegularExpressions;
using System;
using System.Collections.Generic;

namespace IdentityApp.Pages.Identity {
    public class UserTwoFactorSetupModel : UserPageModel {
        public UserTwoFactorSetupModel(UserManager<IdentityUser> usrMgr,
              SignInManager<IdentityUser> signMgr) {
            UserManager = usrMgr;
            SignInManager = signMgr;
        }
        public UserManager<IdentityUser> UserManager { get; set; }
        public SignInManager<IdentityUser> SignInManager { get; set; }
        public IdentityUser IdentityUser { get; set; }
        public string AuthenticatorKey { get; set; }
        public string QrCodeUrl { get; set; }
        /// <summary>
        /// When the user requests the page, the GET handler uses the GetTwoFactorEnabledAsync method to see if the user is already configured for two-factor authentication. If the response is true, then a redirection to the UserTwoFactorManage page is performed .
        ///For users without two-factor authentication enabled, the GET handler method is responsible for presenting the secret key to the user. Authenticator keys are persistent and are used to validate the codes generated by the authenticator every 60 seconds. If the stored key doesn’t match the one used by the authenticator, the user won’t be able to sign in.
        /// </summary>
        /// <returns></returns>
        public async Task<IActionResult> OnGet() {
            await LoadAuthenticatorKeys();
            if (await UserManager.GetTwoFactorEnabledAsync(IdentityUser)) {
                return RedirectToPage("UserTwoFactorManage");
            }
            return Page();
        }
         /// <summary>
         /// </summary>
         /// <param name="confirm"></param>
         /// <returns></returns>   
         public async Task<IActionResult> OnPostConfirm([Required] string confirm) {
            await LoadAuthenticatorKeys();
            if (ModelState.IsValid) {
                // The POST handler receives the code displayed by the user’s authenticator app, which is processed to remove whitespace. Some authenticators, such as the Authy app I use in this book, display tokens in groups of digits separated by a space. These must be removed before the token can be validated, which I do with a regular expression.
                string token = Regex.Replace(confirm, @"\s", "");
                //The arguments are the user object, the name of the token provider class, and the code to validate. In Listing 11-6, I read the user manager’s Options property to get the value of the AuthenticatorTokenProvider property, which specifies the name of the provider. The provider is configured by the AddDefaultTokenProviders extension method added to the Identity configuration in Chapter 8. This method sets up token generators that are suitable for most applications, but I describe how tokens are generated in detail in Part 2 if your application has specific requirements.
                bool codeValid = await UserManager.VerifyTwoFactorTokenAsync(IdentityUser,
                    UserManager.Options.Tokens.AuthenticatorTokenProvider, token);
                if (codeValid) {
                    IEnumerable<String> RecoveryCodes = await UserManager
                        .GenerateNewTwoFactorRecoveryCodesAsync(IdentityUser, 10);
                    TempData["RecoveryCodes"] = RecoveryCodes;
                    foreach(String s in RecoveryCodes){
                        Console.WriteLine($"RecoverCode:{s}");
                    }
                    await UserManager.SetTwoFactorEnabledAsync(IdentityUser, true);
                //In Chapter 9, I enabled authentication cookie validation to effectively sign the user out of the application when their security stamp changes. As I explained in that chapter, this can cause the user to be signed out when other changes are performed, and this includes setting up an authenticator. The ResetAuthenticatorKeyAsync and SetTwoFactorEnabledAsync methods both update the security stamp. To prevent signing the user out of the application, I use the SignInManager<IdentityUser>.RefreshSignInAsync method to refresh the authentication cookie after these methods are called:
                    await SignInManager.RefreshSignInAsync(IdentityUser);
                    return RedirectToPage("UserRecoveryCodes");
                } else {
                    ModelState.AddModelError(string.Empty,
                        "Confirmation code invalid");
                }
            }
            return Page();
        }
        /// <summary>
        /// The user manager’s GetAuthenticatorKeyAsync method retrieves the secret key from the user store. If the method returns null, then no key has been stored. A new key is created and stored using the ResetAuthenticatorKeyAsync method, and the GetAuthenticatorKeyAsync method is called again to retrieve the key from the store. The key is presented to the user directly and formatted in a URL that can be displayed as a QR code. (The format of these URLs is described in Chapter 21.)
        /// </summary>
        /// <returns></returns>
        private async Task LoadAuthenticatorKeys() {
            IdentityUser = await UserManager.GetUserAsync(User);
            AuthenticatorKey = await UserManager.GetAuthenticatorKeyAsync(IdentityUser);
            if (AuthenticatorKey == null) {
                await UserManager.ResetAuthenticatorKeyAsync(IdentityUser);
                AuthenticatorKey = await UserManager.GetAuthenticatorKeyAsync(IdentityUser);
                await SignInManager.RefreshSignInAsync(IdentityUser);
            }
            QrCodeUrl = $"otpauth://totp/ExampleApp:{IdentityUser.Email}"
                        + $"?secret={AuthenticatorKey}";
        }
    }
}